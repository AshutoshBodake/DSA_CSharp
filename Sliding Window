
Sliding Window :
An optimization pattern that converts brute-force O(n²) scans into linear O(n) solutions.

What Sliding Window Solves (Core Idea Recap)

Applicable when the problem involves:

Contiguous subarray / substring
Running range (window) over data

Instead of recalculating from scratch, you:
Add the next element
Remove the previous element

Window moves left → right, keeping computations incremental.

Primary Use Cases of Sliding Window
1. Fixed-Size Window Problems
Window size k is known in advance.

Typical Questions
Maximum / minimum sum of subarray of size k
Average of subarrays of size k
First negative number in every window of size k

Why Sliding Window?
Avoid recomputing sum for each window
Time complexity reduces from O(n*k) → O(n)

2. Variable-Size Window (Dynamic Window)
Window size is not fixed and depends on a condition.

Typical Questions
Longest subarray with sum ≤ K
Smallest subarray with sum ≥ K
Longest substring with at most K distinct characters

Why Sliding Window?
Window expands when condition is valid
Window shrinks when condition breaks

3. Substring / Character Frequency Problems

Very common in interviews.
Typical Questions
Longest substring without repeating characters
Longest substring with at most K distinct characters
Permutation in string
Find all anagrams of a pattern
Key Data Structures
Dictionary / HashMap
Frequency array (int[26])

Why Sliding Window?
Tracks character frequency in current window
Eliminates nested loops

4. Sum / Target-Based Problems

Problems involving continuous sums.

Typical Questions

Subarray with given sum

Count of subarrays with sum = K

Longest subarray with sum = K

Important Insight

Works best when:

All numbers are positive (classic sliding window)

With negatives:

Prefix Sum + HashMap is preferred

5. Optimization & Performance Scenarios

Used when constraints are large (n ≤ 10⁵ or more).

Examples

Streaming data processing

Real-time analytics

Log window aggregation

Rate-limiting logic

Sliding Window vs Brute Force (Interview Angle)
Approach	Time Complexity	Interview Impression
Brute Force	O(n²)	Weak
Sliding Window	O(n)	Strong
Sliding Window + HashMap	O(n)	Advanced
Mental Model for Solving Problems

When reading a problem, ask:
Is the data contiguous?
Do I need max/min/longest/smallest in a range?
Can previous computation help next step?
If YES → Sliding Window

4. In a variable-size sliding window, when do we shrink the window?

A. When right pointer reaches end
B. When condition is satisfied
C. When condition is violated
D. When window size becomes zero

✅ Answer: C

5. You are analyzing API logs to find the maximum number of requests in any 10-second interval. Which approach is optimal?

A. Nested loops
B. Sliding Window
C. Binary Search
D. Divide and Conquer

✅ Answer: B
Backend Mapping: Rate limiting, throttling, monitoring.

6. Sliding Window fails or becomes incorrect when:

A. Window size is fixed
B. Data contains negative numbers (sum-based problems)
C. Using HashMap
D. Using arrays

✅ Answer: B
Explanation: Negative numbers break the monotonic property.

7. Which data structure is MOST commonly used with sliding window for strings?

A. Stack
B. Queue
C. Dictionary / HashMap
D. Tree

✅ Answer: C

8. Longest substring without repeating characters uses:

A. Fixed-size window
B. Variable-size window
C. Two nested loops
D. Recursion

✅ Answer: B

9. In C#, which variable typically represents the window start?

A. i
B. right
C. left
D. count

✅ Answer: C

10. For a stream of telemetry data in Azure, sliding window is commonly used in:

A. Authentication
B. Caching
C. Real-time aggregation
D. Serialization

✅ Answer: C

11. What is the space complexity of a basic sliding window without extra data structures?

A. O(n)
B. O(log n)
C. O(1)
D. O(n²)

✅ Answer: C

12. Which problem requires Prefix Sum + HashMap instead of Sliding Window?

A. Max sum subarray of size K
B. Longest substring with unique characters
C. Count subarrays with sum = K (includes negatives)
D. Average of subarrays of size K

✅ Answer: C

13. In backend systems, sliding window is heavily used in:

A. ORM mapping
B. Rate limiting & throttling
C. Dependency injection
D. Serialization

✅ Answer: B

14. What is the correct order in a sliding window loop?

A. Remove → Add → Update
B. Add → Update → Remove
C. Add → Shrink (if needed) → Update
D. Update → Add → Shrink

✅ Answer: C

15. Why do interviewers prefer Sliding Window solutions?

A. Shorter code
B. Uses recursion
C. Demonstrates optimization & problem decomposition
D. Uses advanced libraries

✅ Answer: C
Problem decomposition is the strategy of breaking a large, complex problem into smaller, 
more manageable sub-problems to make it easier to understand, analyze, and solve systematically

int left = 0;
for (int right = 0; right < n; right++)
{
    // include right element

    while (condition is violated)
    {
        // exclude left element
        left++;
    }

    // update answer
}


Variable Size Sliding Window Approach:
While the basic sliding window technique involves a fixed-size window that moves through the data structure, 
the variable-size sliding window introduces flexibility by allowing the window size to change dynamically based on certain conditions.

This is particularly useful when the problem involves finding a subarray or substring that satisfies certain criteria.
In this approach, instead of maintaining a fixed-size window throughout the entire process, you adjust the window size as needed. 
The window can grow or shrink depending on the problem’s requirements.

Example Problem: Longest Subarray with Sum Less Than K

Problem: Given an array of positive integers and an integer K, find the length of the longest subarray whose sum is less than K.
Initialize variables: left to track the start of the subarray and right to iterate through the array.
Initialize windowSum as the first element of the array.
Initialize maxLength to keep track of the maximum subarray length.
Press enter or click to view image in full size.

Fixed Size Window
public static int MaxSumSubarray(int[] arr, int k)
{
    int n = arr.Length;

    int maxSum = 0;
    for (int i = 0; i < k; i++)
    {
        maxSum += arr[i];
    }
    int windowSum = maxSum;
    for (int i = k; i < arr.Length; i++)
    {
        windowSum += arr[i] - arr[i - k];
        maxSum = Math.Max(windowSum, maxSum);
    }
    return maxSum;
}

Variable Size Sliding Window
public static int LengthOfLongestSubstring(string s)
{
    int n = s.Length;
    int maxLength = 0;
    int start = 0;
    int end = 0;
    Dictionary<char, int> dict = new Dictionary<char, int>();

    for (end = 0; end < n; end++)
    {
        char currentChar = s[end];
        if (dict.ContainsKey(currentChar) && dict[currentChar] >= start)
        {
            start = dict[currentChar] + 1;
        }
        dict[currentChar] = end;
        maxLength = Math.Max(maxLength, end - start + 1);
    }
    return maxLength;
}
